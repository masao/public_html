\documentstyle[a4j]{jarticle}
%\author{98513 高久雅生}
%\title{システムコミュニケーション論2\\
%（システムインタフェース）}
%\date{1998年10月7日}

\begin{document}
% \maketitle

\begin{flushright}
1998年10月7日\\
システムコミュニケーション論II\\
（システムインタフェース）\\
98513 高久雅生
\end{flushright}

\begin{center}
 \huge\bf The Common Object Request Broker : \\
 Architecture and Specification
\end{center}

\setcounter{section}{1}
%\setcounter{subsection}{1}
%\setcounter{subsubsection}{4}

\section{CORBA Overview}
\subsection{Structure of an Object Request Broker}
\subsubsection{Object Request Broker}
\subsubsection{Clients}
\subsubsection{Object References}

\subsubsection{OMG Interface Definition Language
（OMG インタフェース定義言語）}

OMGインタフェース定義言語 (IDL) は
オブジェクトのインタフェースを定義することで
その型を定義している。
インタフェースは名前つきオペレーションと
そのオペレーションに対するパラメータの集合から構成される。
IDLはORBによるオブジェクトの操作を記述するための
概念的な枠組を提供しているが、
ORBの動作のためにIDLのソースコードを必要としないことに留意しなさい。
スタブ・ルーチンや実行時のインタフェース・レポジトリの形式で
等価な情報が入手可能である限りには、
ある特定のORBは正しく機能できるかも知れない。

IDLはある特定のオブジェクトインプリメンテーションが
その潜在的なクライアントへ
入手可能なオペレーションや起動のされ方を伝える方法である。
IDLの定義によれば、
CORBAオブジェクトを特定のプログラミング言語・オブジェクトシステムに
マッピングすることが可能である。

   \subsubsection{Mapping of OMG IDL to Programming Language\\
   （OMG IDLのプログラミング言語へのマッピング）}

ことなるオブジェクト指向・非オブジェクト指向プログラミング言語は
違うやりかたでCORBAオブジェクトにアクセスする方が良いかも知れない。
オブジェクト指向言語では、
CORBAオブジェクトをプログラミング言語オブジェクトとみなす方が
望ましい。
非オブジェクト指向言語でも、
オブジェクトリファレンス、メソッド名などの正確なORB表現を
隠蔽するのは良い考えである。
OMG IDLのあるプログラミング言語への特定のマッピングは
全てのORB実装に対して同一となるべきである。
言語のマッピングはその言語独特のデータ型と
ORBを通じてオブジェクトへアクセスする手続きインタフェースを含んでいる。
このインタフェースはクライアントのスタブインタフェース
（オブジェクト指向言語では不要）、動的起動インタフェース、
実装スケルトン、オブジェクトアダプタ、
直接のORBインタフェースの構造を含んでいる。

言語マッピングはクライアントや実装における制御スレッド
とオブジェクト起動の間のやりとりも定義している。
もっともよくあるマッピングとしては同期呼び出し、
つまりオブジェクトオペレーションが完了すると
ルーチンがreturnするというものが提供されている。
追加のマッピングとして、
初期化のための呼び出しやそのプログラムに戻る制御が提供されることもある。
このような場合には、
さらに言語特有のルーチンとして、
オブジェクト起動を制御する
プログラム側のスレッドが同期して提供されなければならない。

\subsubsection{Client Stub（クライアントスタブ）}

非オブジェクト指向言語のマッピングでは、
各インタフェース型に対するスタブへのプログラミングインタフェースがあるだろう。
一般に、スタブは
あるオブジェクトにおけるOMG IDLで定義されたオペレーションへのアクセスを与える。
この方法は一度OMG IDLとその特定のプログラミング言語へのマッピングに精通した
プログラマには予想することが容易である。
スタブは残りのORBに対して、
特定のORBコアに対して（おそらく最適化された）privateなインタフェースを使って
呼び出しを行なう。
もし複数のORBが取得できれば、
異なったORBに対応する異なるスタブが存在することもある。
この場合には、ORBと言語マッピングは特定のオブジェクトリファレンスに対して
正しいスタブと結び付けるよう協調する必要がある。

C++やSmalltalkのようなオブジェクト指向言語は
スタブインタフェースを必要としない。

\subsubsection{Dynamic Invocation Interface（動的起動インタフェース）}

オブジェクト起動の動的な構築を行なうインタフェースも利用できる。
つまり、
特定のオブジェクトの特定のオペレーションを指定する
スタブルーチンを呼ぶのではなく、
クライアントは起動すべきオブジェクトを指定したり、
実行すべきオペレーションを指定したり、
呼びだしを通じてオペレーションに渡すべきパラメータを指定したりする。
クライアントのコードは実行すべきオペレーションや
渡されるパラメータの型に関する情報を補わなければならない
（多分これはインタフェースレポジトリや他の実行時ソースから取得する）。
動的起動インタフェースの性質は
あるプログラミング言語から別の言語へのマッピングではだいぶ
異なるかも知れない。

\subsubsection{Implementation Skeleton（実装スケルトン）}

ある特定の言語マッピングと
おそらくオブジェクトアダプタに依存する部分については、
オブジェクトの各型を実現するメソッドへのインタフェースがあるだろう。
このインタフェースは一般的にup-callインタフェースとなる。
つまり、オブジェクト実装ではそのインタフェースに従ったルーチンを書き、
ORBはスケルトンを通じてそれらを呼び出す。

スケルトンの存在は対応するクライアントスタブの存在を示すものではない
（クライアントは動的起動インタフェースを通じても要求を出せる）。

実装のメソッドを起動するのにスケルトンを利用しないオブジェクトアダプタを
書くことができる。
例えば、
Smalltalkのような言語では実装を動的に生成することも可能かも知れない。

\end{document}
